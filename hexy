# Game Call Phaze - overlapping patterns (rotate, etc)

# Initialization ==================================================================================

import sys

# print(sys.version)

from sys import winver
import pygame
from pygame import gfxdraw
from pygame.constants import KEYUP
import os
import math
import random
import helper

from enum import IntEnum
from enum import Enum

from helper import board

pygame.font.init()
pygame.mixer.init()
pygame.init()

# Constants =======================================================================================

# Initial Display Size
WIDTH  = 1000
HEIGHT = 1000

WIN = pygame.display.set_mode((WIDTH, HEIGHT))

pygame.display.set_caption("Habitat for Humanity Game")

# Color Constants
WHITE = (255,255,255,128)
BACKGROUND = (32,32,32)

# Mouse Button Constants
LEFT        = 1
CENTRE      = 2
RIGHT       = 3
SCROLL_UP   = 4
SCROLL_DOWN = 5

# Coordinate Constants
X = 0
Y = 1

class VASARELY_COLORS(Enum):

  PINK     = (181, 42,142)
  PURPLE   = ( 90, 24,120)
  
  BLUE     = ( 39,105,176)
  CYAN     = ( 79,168,219)
  NAVY     = ( 42, 40,143)

  DORANGE  = (227,102, 79)
  LORANGE  = (250,147, 95)
  
  LYELLOW  = (244,255,173)
  DYELLOW  = (247,194,119)
  
  LGREEN   = (  0,173,147)
  DGREEN   = (  0,110,110)

  RED      = (222, 33, 49)
  MAROON   = (135, 26, 35)
  PEACH    = (247,194, 11) 

  BLACK    = (  0,  0,  0)
  GRAY     = (122,135,191)

class COLORS(IntEnum):

  PINK    = 0
  PURPLE  = 1
  CYAN    = 2
  NAVY    = 3
  BLUE    = 4
  DORANGE = 5
  LORANGE = 6
  LYELLOW = 7
  DYELLOW = 8
  LGREEN  = 9
  DGREEN  = 10
  PEACH   = 11
  RED     = 12
  MAROON  = 13
  BLACK   = 14
  GRAY    = 15

BULLET_HIT_SOUND  = pygame.mixer.Sound(os.path.join('C:/Users/ssbbc/Desktop/Brad/python/assets', 'Grenade.mp3'))
BULLET_FIRE_SOUND = pygame.mixer.Sound(os.path.join('C:/Users/ssbbc/Desktop/Brad/python/assets', 'Silencer.mp3'))

HEALTH_FONT = pygame.font.SysFont('comicsans', 40)
WINNER_FONT = pygame.font.SysFont('comicsans', 12)

# Globals =========================================================================================

# Methods =========================================================================================

def get_Color():

  clr = int(random.random()*16)

  ret = VASARELY_COLORS.PINK.value

  if   clr == COLORS.PINK:    ret = VASARELY_COLORS.PINK.value
  elif clr == COLORS.PURPLE:  ret = VASARELY_COLORS.PURPLE.value
  elif clr == COLORS.CYAN:    ret = VASARELY_COLORS.CYAN.value
  elif clr == COLORS.NAVY:    ret = VASARELY_COLORS.NAVY.value
  elif clr == COLORS.BLUE:    ret = VASARELY_COLORS.BLUE.value
  elif clr == COLORS.DORANGE: ret = VASARELY_COLORS.DORANGE.value
  elif clr == COLORS.LORANGE: ret = VASARELY_COLORS.LORANGE.value
  elif clr == COLORS.LYELLOW: ret = VASARELY_COLORS.LYELLOW.value
  elif clr == COLORS.DYELLOW: ret = VASARELY_COLORS.DYELLOW.value
  elif clr == COLORS.LGREEN:  ret = VASARELY_COLORS.LGREEN.value
  elif clr == COLORS.DGREEN:  ret = VASARELY_COLORS.DGREEN.value
  elif clr == COLORS.PEACH:   ret = VASARELY_COLORS.PEACH.value
  elif clr == COLORS.RED:     ret = VASARELY_COLORS.RED.value
  elif clr == COLORS.MAROON:  ret = VASARELY_COLORS.MAROON.value
  elif clr == COLORS.BLACK:   ret = VASARELY_COLORS.BLACK.value
  elif clr == COLORS.GRAY:    ret = VASARELY_COLORS.GRAY.value
  else:                       ret = VASARELY_COLORS.GRAY.value

  return ret
  #   clr = int(random.random()*16)

  #   match clr:
      
  #     case COLORS.PINK:    return PINK
  #     case COLORS.PURPLE:  return PURPLE
  #     case COLORS.CYAN:    return CYAN
  #     case COLORS.NAVY:    return NAVY
  #     case COLORS.BLUE:    return BLUE
  #     case COLORS.DORANGE: return DORANGE
  #     case COLORS.LORANGE: return LORANGE
  #     case COLORS.LYELLOW: return LYELLOW
  #     case COLORS.DYELLOW: return DYELLOW
  #     case COLORS.LGREEN:  return LGREEN
  #     case COLORS.DGREEN:  return DGREEN
  #     case COLORS.PEACH:   return PEACH
  #     case COLORS.RED:     return RED
  #     case COLORS.MAROON:  return MAROON
  #     case COLORS.BLACK:   return BLACK
  #     case COLORS.GRAY:    return GRAY
  #     case _:              return -16

def initialize_Game():
  
  return

# Objects =========================================================================================

class App:

  def __init__(self, size):
      
    self.size = size

    self.grid = []           # list holding the cell objects
    self.current_cell = (0,0) # which hexagonal cell has the focus
    self.grid_size = 7       # of hexagonal layers - defaults to 4
    self.fps = 60

class point:

  def __init__(self, x, y) -> None:
    
    self.x = x
    self.y = y

class hex:

  x = 0
  y = 0

  def __init__(self, x, y, diameter, color):
  
    self.x = x               # horizontal position of centre
    self.y = y               # vertical position of centre
    
    self.diameter = diameter # full diameter width of hexagon
    self.radius = diameter/2 # distance from center to corner point
    
    self.width = math.cos(math.pi/6)*diameter
    
    self.center = point(self.x, self.y) # Center Point
    self.points = []

    self.orientation = 0
    
    self.color = color
    self.centerColor = color

    self.hit = False
    
    # Calculate Corner Points

    # Offsets
    oX = math.cos(math.pi/6)*self.radius # Offset x
    oY = math.sin(math.pi/6)*self.radius # Offset Y

    # Aliases
    sX = self.x
    sY = self.y
    r = self.radius
    pts = self.points

    pts.append((sX,      sY + r ))
    pts.append((sX + oX, sY + oY))
    pts.append((sX + oX, sY - oY))
    pts.append((sX,      sY - r ))
    pts.append((sX - oX, sY - oY))
    pts.append((sX - oX, sY + oY))
  
  def draw(self):

    def draw_text():
      
      pts = self.points

      WIN.blit(WINNER_FONT.render('0', 1, WHITE), (pts[0][0], pts[0][1]))
      WIN.blit(WINNER_FONT.render('1', 1, WHITE), (pts[1][0], pts[1][1]))
      WIN.blit(WINNER_FONT.render('2', 1, WHITE), (pts[2][0], pts[2][1]))
      WIN.blit(WINNER_FONT.render('3', 1, WHITE), (pts[3][0], pts[3][1]))
      WIN.blit(WINNER_FONT.render('4', 1, WHITE), (pts[4][0], pts[4][1]))
      WIN.blit(WINNER_FONT.render('5', 1, WHITE), (pts[5][0], pts[5][1]))

    w = WIN
    c = self.color

    pygame.gfxdraw.filled_polygon(w, self.points, self.color)
    # pygame.gfxdraw.filled_circle(WIN, self.x, self.y, int(app.size*0.65), self.centerColor)
    # pygame.gfxdraw.circle(WIN, self.x, self.y, int(app.size*0.65), (128,128,128))

    if self.hit:
      
      pygame.gfxdraw.circle(WIN, int(self.x), int(self.y), int(self.diameter/2), VASARELY_COLORS.RED.value)

      draw_text()

      # draw_text = WINNER_FONT.render('3', 1, WHITE)

      # WIN.blit(WINNER_FONT.render('0', 1, WHITE), (self.points[0][0], self.points[0][1]))
      # WIN.blit(WINNER_FONT.render('1', 1, WHITE), (self.points[1][0], self.points[1][1]))
      # WIN.blit(WINNER_FONT.render('2', 1, WHITE), (self.points[2][0], self.points[2][1]))
      # WIN.blit(WINNER_FONT.render('3', 1, WHITE), (self.points[3][0], self.points[3][1]))
      # WIN.blit(WINNER_FONT.render('4', 1, WHITE), (self.points[4][0], self.points[4][1]))
      # WIN.blit(WINNER_FONT.render('5', 1, WHITE), (self.points[5][0], self.points[5][1]))

  def move(self):

    self.hitTest()

  def hitTest(self):

    x = pygame.mouse.get_pos()[X]
    y = pygame.mouse.get_pos()[Y]

    if(math.dist((self.x, self.y), (x, y))<=self.radius): self.hit = True
    else:                                                 self.hit = False

def load_grid():

  app.grid.clear

  temp = []

  colPos = 0
  rowPos = 0

  # size = (WIDTH - 100)/(gridSize*2)/math.cos(math.pi/6)
  
  #  Determine Center
  # print(WIDTH/2, HEIGHT/2)

  # Determine size of hex cells
  # size = (WIDTH - 100)/gridSize

  # Add Row

  # Load Center row  
  # for row in range(gridSize):
    # temp.append(hex(colPos, rowPos, size, get_Color()))

    # for col in range(len(board[row])):
      # print(1) 

def load_board():

  sz = app.size*1/math.cos(math.pi/6)
  
  app.grid.clear

  temp = []

  # for row in range(len(board)):
    
  #   print(helper.board[row])

  for col in range(app.grid_size):
    
    rowPos = HEIGHT/2
    colPos = app.size + col*sz*math.cos(math.pi/6)

    # if row%2==0: colPos += sz*math.cos(math.pi/6)

    temp.append(hex(colPos, rowPos, sz, get_Color()))

  app.grid.append(temp)

  temp.clear

def draw_board():
    
  for row in range(len(app.grid)):
    for col in range(len(app.grid[row])):
      app.grid[row][col].draw()

def draw_window():

  WIN.fill(BACKGROUND)

  draw_board()

  w = WIDTH/(app.grid_size+1)

  pygame.draw.rect(WIN, (128,0,0), (w/2, w/2, WIDTH-w, HEIGHT-w), 1, 15)

  pygame.display.update()

app = App(WIDTH/(7+1))
app.size = WIDTH/(app.grid_size+1)

# Event handlers ==================================================================================

def handle_keys(key):

  if   key == pygame.K_q: print("Up Left")                                    
  elif key == pygame.K_w: print("Up")
  elif key == pygame.K_e: print("Up Right")
  elif key == pygame.K_a: print("Down Left")
  elif key == pygame.K_s: print("Down")
  elif key == pygame.K_d: print("Down Right")

def increment_grid():

  app.grid_size += 2
  app.size = math.floor(WIDTH/(app.grid_size+1))
  app.grid.clear()

  load_board()

def decrement_grid():

  app.grid_size -= 2  
  app.size = math.floor(WIDTH/(app.grid_size+1))
  app.grid.clear()

  load_board()

def handle_mouse(button):

  print(pygame.mouse.get_pos())

  if   button == LEFT:        increment_grid()
  elif button == CENTRE:      print("Wheel")
  elif button == RIGHT:       decrement_grid()
  elif button == SCROLL_UP:   print("Scroll Up")
  elif button == SCROLL_DOWN: print("Scroll Down")

def handle_move():

  for row in range(len(app.grid)):
    for col in range(len(app.grid[row])):
      app.grid[row][col].move()  

# Main Loop =======================================================================================

print(app.size)

load_board()
load_grid()

def main():

  clock = pygame.time.Clock()

  run = True

  while run:

    clock.tick(app.fps)

    for event in pygame.event.get():
      
      if event.type == pygame.QUIT:
        run = False
        pygame.quit()
      
      if event.type == pygame.KEYUP:         handle_keys(event.key)
      if event.type == pygame.MOUSEBUTTONUP: handle_mouse(event.button)

      handle_move()

    draw_window()  
    

if __name__ == "__main__":
  main()



